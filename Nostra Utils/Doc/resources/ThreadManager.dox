/**
\page ThrdMngr_tut Thread Management

\brief On this page, the use and further details of the thread management system of Nostra will be explained.

\tableofcontents

\section sec_include Including the Thread Management

The easiest way to include the thread management is to include the file "nostrautils/thread/Threads.hpp". It
includes all the other files of the thread management and therefore has all the features that the thread 
management system has to offer.

It would also be possible to include each file individually, but this poses no benefit to using 
"nostrautils/thread/Threads.hpp".

In the following examples, it is always assumed that "nostrautils/thread/Threads.hpp" is included.

\section sec_tasks Tasks

To execute functionality in a different thread, Nostra uses the class \link nostra::utils::thread::Task Task 
\endlink, which in the most basic sense is the combination of a function pointer (or any other sort of 
invocable, like a lambda) and the parameters that are required to call that invocable. It is also important 
that the Task on its own does not do any multithreading yet, nor does it enforce any thread safety (e.g. like
 locking its resources).

\subsection subsec_TaskConstruct Constructing a Task

To create a Task, the function \link nostra::utils::thread::makeTask() makeTask() \endlink can be used. The 
instantiation of a Task may look like this:

\code{.cpp}
NOU::int32 addFive(NOU::int32 i)
{
    return i + 5;
}

int main()
{
    /*
     * Create a new task that executes the function addFive() and passes "1" as the parameter.
     */
    auto task = NOU::NOU_THREAD::makeTask(&addFive, 1);

    return 0;
}
\endcode

There are a few interesting things about this example:
<ul>
    <li>
        It uses the <tt>auto</tt> keyword, which is because Tasks rely heavily on templates and may have a 
        very long list of template parameters (especially if the invocable that is called has a lot of 
        parameters itself). This is also the primary reason for the existence of \link 
        nostra::utils::thread::makeTask() makeTask() \endlink - the function uses template parameter deduction
        to avoid having to write down long template parameter lists.
    </li>
    <li>
        The function is explicitly passed as <tt>&addFive</tt> and not as just <tt>addFive</tt>. This is 
        required and not optional - passing the function as <tt>addFive</tt> will result in a compile error.
    </li>
</ul>

It is also possible to use Tasks to execute member functions:

\code{.cpp}
class A
{
public:
    NOU::int32 addFive(NOU::int32 i) const
    {
        return i + 5;
    }
}

int main()
{
    /*
     * In the case of member functions, the first parameter needs to be the object that the function will be
     * executed with. The remaining parameters of the function will follow after that object.
     */
    auto task = NOU::NOU_THREAD::makeTask(&A::get, A(), 1);

    return 0;
}
\endcode

Passing objects to a task leads to another important subject: The proper way to pass objects and avoiding 
unnecessary copies of that object. If the object is only needed within the task and not outside it, it is 
possible to move the object into the task - just as it was done in the previous example with <tt>A()</tt>. If 
it is required to store the object outside the task and a reference to that object is required in task, it is 
the best option to pass pointer to that object:

\code{.cpp}
class A
{
public:
    void doStuff()
    {
        //...
    }
}

void function(A *a)
{
    a->doStuff();
}

int main()
{
    A a;

    auto task = NOU::NOU_THREAD::makeTask(&function, &a);

    return 0;
}
\endcode

It is <b>not</b> possible to pass references to a task and trying to do so will either result in a copy of the
 object (in the case that an object is passed to \link nostra::utils::thread::makeTask() makeTask() \endlink 
as-is and not as a pointer):

\code{.cpp}
int main()
{
    /*
     * A and function are the same class and function respectively from the previous example.
     */

    A a;

    //Pass "a" as plain object.
    auto task = NOU::NOU_THREAD::makeTask(&function, a);

    return 0;
}
\endcode

or in a compile error, as it is also not possible to explicitly define the template parameter of \link 
nostra::utils::thread::makeTask() makeTask() \endlink as a reference:

\code{.cpp}
int main()
{
    /*
     * A and function are the same class and function respectively from the previous example.
     */
    
    A a;

    auto task = NOU::NOU_THREAD::makeTask<decltype(&function), A&>(&function, a);

    return 0;
}
\endcode

Also, Nostra does not provide any functionality like the STL's std::reference_wrapper, mainly because that 
would cause unnecessary overhead.

\subsection subsec_TaskExec Executing a Task

Executing a Task is simply done by calling \link nostra::utils::thread::Task::execute execute() \endlink. 
Since the Task itself does not any multithreading on its own, the execution is entirely done by the thread 
that called \link nostra::utils::thread::Task::execute execute() \endlink.

\subsection subsec_TaskResultAccess Accessing the results of a Task

Because the invocable that is executed by a Task can return a value, the task also has mechanics to access 
that result. For reasons that are described in the chapter \ref subsec_Task_AbstractTask, \link 
nostra::utils::thread::Task::execute execute() \endlink does not return the result that was produced by the 
invocable. Instead, the result can be accessed using \link nostra::utils::thread::Task::getResult getResult() 
\endlink and \link nostra::utils::thread::Task::moveResult moveResult() \endlink.

\attention
Calling \link nostra::utils::thread::Task::getResult getResult() \endlink or \link 
nostra::utils::thread::Task::moveResult moveResult() \endlink is only valid if \link 
nostra::utils::thread::Task::execute execute() \endlink has been called before. Otherwise \link 
nostra::utils::core::ErrorCodes::INVALID_OBJECT ErrorCodes::INVALID_OBJECT \endlink will be pushed to the 
\link nostra::utils::core::ErrorHandler error handler \endlink.

\par getResult()

\link nostra::utils::thread::Task::getResult getResult() \endlink returns a reference (or a const-reference) 
to the result. This reference is only valid as long as the Task instance that is was obtained from is valid. 
Accessing the result would look like this:

\code{.cpp}
NOU::int32 addFive(NOU::int32 i)
{
    return i + 5;
}

int main()
{
    /*
    * Create a new task that executes the function addFive() and passes "1" as the parameter.
    */
    auto task = NOU::NOU_THREAD::makeTask(&addFive, 1);
    task.execute();
    
    NOU::int32 &iRef = task.getResult();
    
    return 0;
}
\endcode

\par moveResult()

\link nostra::utils::thread::Task::moveResult moveResult() \endlink returns a R-Value reference to the result. 
This can be useful if the result still needs to exist, even if the task that produced it has left scope (a 
user can simply move the result from the Task to a variable in another scope).

\code{.cpp}
NOU::int32 addFive(NOU::int32 i)
{
    return i + 5;
}

int main()
{
    /*
    * Create a new task that executes the function addFive() and passes "1" as the parameter.
    */
    auto task = NOU::NOU_THREAD::makeTask(&addFive, 1);
    task.execute();
    
    NOU::int32 iRef = task.moveResult();
    
    return 0;
}
\endcode

\attention
If the return type of the invocable is <tt>void</tt>, the return type of \link 
nostra::utils::thread::Task::getResult getResult() \endlink and \link nostra::utils::thread::Task::moveResult 
moveResult() \endlink will also be <tt>void</tt>. Since there is nothing to return, both member functions will
not do anything. The return type can however be a problem with code like this:

\code{.cpp}
/*
* R: The return type
* I: The invocable type
* ARGS: The argument types
*/
template<typename R, typename I, typename... ARGS>
void executeAndPrintResult(NOU::NOU_THREAD::Task<R, I, ARGS...> &task)
{
    //execute task and store the result
    task.execute();
    auto &result = task.getResult();
    
    //print the result using the STL
    std::cout << result << std::endl;
}

void function()
{
    //...
}

int main()
{
    auto task = NOU::NOU_THREAD::makeTask(&function);
    
    //compile error in executeAndPrintResult(), since a variable of type void is not allowed
    executeAndPrintResult(task);
}
\endcode

\subsection subsec_Task_AbstractTask The class AbstractTask

\subsubsection subsubsec_AbstractConcreteClassModel The Abstract-Concrete-Model

To ease understanding the necessity of AbstractTask, this section will explain the Abstract-Concrete-Model,
which is a model not only used by the Task class, but also by a bunch of other thread management related
classes.

The model is used when a class with template parameter(s) is required (as it is the case with the Task class),
but references to different instantiations of that template (aka. instances with different template
parameters) should be stored in a single container.

The model itself is simple:

\dot
digraph example
{
node [shape=record, fontname=Helvetica, fontsize=10];
a [ label="AbstractClass"];
c [ label="ConcreteClass"];
c -> a [ arrowhead="empty" ];
}
\enddot

With <tt>AbstractClass</tt> being a class that has no template parameters and <tt>ConcreteClass</tt> being a
class that has all the required template parameters. <tt>AbstractClass</tt> would then already declare the
functions (as pure virtual) for all the required functionality (those functions have to work without any
template parameters as well) and <tt>ConcreteClass</tt> would implement those functions.

\subsubsection AbstractTask

As already pointed out, the Task class uses the Abstract-Concrete-Model (with \link
nostra::utils::thread::internal::AbstractTask AbstractTask \endlink being the abstract class). The model is
required, because the \link sec_threadManager Thread Manager \endlink needs to execute tasks that take
different parameters or have different invocables (and therefore, the template parameters of Task are
different). To solve this problem, instead of storing the Tasks themselves, the thread manager will store
references to AbstractTask.

The class AbstractTask only provides a single pure virtual function: <tt>execute()</tt> (which is the only
function that is required by the thread manager). This is also the reason why \link
nostra::utils::thread::Task::execute execute() \endlink does not return the result of the invocable that it
calls - it simply has no knowledge of any parameter types (which of course also includes the return type).

\section sec_errorHandling Error Handling

In some way, multi threaded error handling is the same as single threaded error handling. The error handler can be obtained using \link nostra::utils::core::getErrorHandler() getErrorHandler() \endlink and errors can be pushed just as if the program was single threaded. However, there is a difference: As soon as multiple threads are involved there is not only one error handler but there is one error handler per thread. This ensures thread safety, but also means that errors are not shared between threads.

\note
If the error handling system of Nostra is not the only system being used (e.g. when there are threads being created using the STL), there will be no error handler for these threads and calling \link nostra::utils::core::getErrorHandler() getErrorHandler() \endlink will result in an error.

\section sec_asyncTaskResult AsyncTaskResult

The class \link nostra::utils::thread::AsyncTaskResult AsyncTaskResult \endlink is the simplest way to execute code in a different thread. It is capable of executing a single task and can easily be used to "outsource" a task while the main thread is doing something different.

\subsection subsec_asyncTaskResultUsage Usage

The first step of creating an instance of \link nostra::utils::thread::AsyncTaskResult AsyncTaskResult \endlink, is creating the \link nostra::utils::thread::Task Task \endlink that will be executed in a different thread:

\code{.cpp}
NOU::int32 addFive(NOU::int32 i)
{
    return i + 5;
}

int main()
{
    auto task = NOU::NOU_THREAD::makeTask(&addFive, 1);

    return 0;
}
\endcode

Afterwards, the AsyncTaskResult can be constructed:

\code{.cpp}
NOU::int32 addFive(NOU::int32 i)
{
    return i + 5;
}

int main()
{
    auto task = NOU::NOU_THREAD::makeTask(&addFive, 1);

    AsyncTaskResult<NOU::int32, decltype(&addFive), NOU::int32> asyncTaskResult(task);

    return 0;
}
\endcode

There are two interesting parts about the line in which the AsyncTaskResult gets created:

\note
Other than the task class, AsyncTaskResult does not provide a function like \link 
nostra::utils::thread::makeTask() makeTask() \endlink. This is because AsyncTaskResult can not be moved or 
copied.

As soon as the instance is created, the task is scheduled for execution (however, no assumptions can be made on when the task will be executed).

\subsubsection subsubsec_asyncTaskResult_stateQuery Querying the State
The state of the execution can be queried using \link nostra::utils::thread::internal::AbstractAsyncTaskResult::getState() AbstractAsyncTaskResult::getState() \endlink (the states are represented by the enum \link nostra::utils::thread::internal::AbstractAsyncTaskResult AbstractAsyncTaskResult::State \endlink). The possible states are:

<table>
    <tr><th>Enumeration element name</th><th>Description</th></tr>
    <tr><td>NOT_STARTED</td><td></td>The execution has not been started yet.</tr>
    <tr><td>EXECUTING_SYNC</td><td></td>The execution has manually been triggered by a user and is currently executed in the thread that triggered that execution (see \link subsubsec_asyncTaskResult_resultProduction here \endlink).</tr>
    <tr><td>EXECUTING_ASYNC</td><td></td>The execution is currently done asynchronously.</tr>
    <tr><td>DONE</td><td></td>The execution has finished.</tr>
</table>

\subsubsection subsubsec_asyncTaskResult_resultProduction Producing a Result

Since multithreading is often used to calculate a result, AsnycTaskResult (as the name implies) provides functionality to produce a result. To do so, the class uses the functionality to produce the result that is already provided by the tasks (long story short: the return value of the task is the result of the AsyncTaskResult). Obviously, if there is no return value (return type is \p void) there is no result to obtain.

The result is produced after the task is done executing and can be queried using \link nostra::utils::thread::AsyncTaskResult::getResult() AsyncTaskResult::getResult() \endlink. If the result is not produced when <tt>getResult()</tt> is called, the production of the result will be forced. If the task is not already being executed in a different thread, then the task will be executed in the thread that called <tt>getResult()</tt>. If the result should be produced (or the task simply should be executed at a certain point of time) but the value if not necessarily required, \link nostra::utils::thread::internal::AbstractAsyncTaskResult::makeResult() AbstractAsyncTaskResult::makeResult() \endlink can be used.

\note
When the return type of the task that was passed to the AsyncTaskResult is \p void, <tt>getResult()</tt> and <tt>makeResult()</tt> are equivalent.

\subsection subsec_asyncTaskResult_ErrorHandling Error Handling

Generally, error handling works just as it was already explained in \link sec_errorHandling this chapter \endlink. It should however be noted that it is not possible to access the errors of an instance of AsyncTaskResult outside of it (unless the user sets up such functionality). 

\subsection subsec_asyncTaskResult_AbstractConcreteModel Abstract-Concrete-Model

As the names of the classes that were linked to in this chapter might have implied: There are two classes that make up the AsyncTaskResult. The classes are \link nostra::utils::thread::AsyncTaskResult AsyncTaskResult \endlink and \link nostra::utils::thread::internal::AbstractAsyncTaskResult AbstractAsyncTaskResult \endlink. This is because AsyncTaskResult was modeled after the \link subsubsec_AbstractConcreteClassModel Abstract-Concrete-Model \endlink.



\section sec_lockingResources Locking Resources

This chapter will show how to lock resources in order to avoid race conditions and synchronize multiple threads.

\subsection subsec_mutex Mutexes

Mutexes are the most basic way to lock resources. They can be locked and unlocked.

\par Example:

This example shows how to do some calculations and synchronize the std::cout output stream after the 
calculations are done using <tt>calculate()</tt>. These calculations can be done simultaneously.

\code{.cpp}

NOU::THREAD::Mutex mutex;

void doStuff()
{
    NOU::int32 calc = calculate();

    mutex.lock();
    std::cout << "doStuff(): " << calc << std::endl;
    mutex.unlock()
}

void doOtherStuff()
{
    NOU::int32 calc = calculate();

    mutex.lock();
    std::cout << "doMoreStuff(): " << calc << std::endl;
    mutex.unlock()
}

\endcode

Assuming that the functions are called simultaneously from two different threads, this would be the order in
which the functions would be executed. For easier understanding, the <tt>calculate()</tt> function of
<tt>doOtherStuff()</tt> will take longer than that of <tt>doStuff()</tt>.

<table>
    <tr>
        <th>Thread 1 (executes doStuff())</th>
        <th>Thread 2 (executes doOtherStuff())</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>NOU::int32 calc = calculate();</td>
        <td rowspan="2">NOU::int32 calc = calculate();</td>
        <td rowspan="2">
            Both threads call <tt>calculate()</tt>. Thread 1 finishes first with calculating and 
            already locks the mutex.
        </td>
    </tr>
    <tr>
        <td>mutex.lock();</td>
    </tr>
    <tr>
        <td>std::cout << "doStuff(): " << calc << std::endl;</td>
        <td rowspan="2">mutex.lock()</td>
        <td rowspan="2">
            Thread 1 already prints to the stream and unlocks the mutex afterwards. Since the mutex was 
            already locked when Thread 2 tried to lock it, the <tt>mutex.lock()</tt> in Thread 2 will not 
            return until the mutex is unlocked again.
        </td>
    </tr>
    <tr>
        <td>mutex.unlock();</td>
    </tr>
    <tr>
        <td rowspan="2"></td>
        <td>std::cout << "doMoreStuff(): " << calc << std::endl;</td>
        <td rowspan="2">
            Now that the mutex is unlocked again, <tt>mutex.lock()</tt> in Thread 2 is able to lock it again 
            for itself. It can now print to the stream and unlock the mutex afterwards. Thread 1 is done 
            executing its function.
        </td>
    </tr>
    <tr>
        <td>mutex.unlock()</td>
    </tr>
</table>
  

    
\section sec_threadManager The Thread Manager

The class \link nostra::utils::thread::ThreadManager ThreadManager \endlink is the central system of the thread management system of Nostra. It is a singleton that acts as a thread pool but also schedules the Tasks that will be executed by the threads.
    
As already stated in the \link sec_tasks chapter about tasks \endlink, does the Thread Manager use the \link nostra::utils::thread::Task Task \endlink class (or to be more precise the class \link nostra::utils::thread::internal::AbstractTask AbstractTask \endlink).

Despite being the central component of the thread management system, a user usually interacts rather little with it (there are other interfaces, like \link nostra::utils::thread::AsyncTaskResult AsyncTaskResult \endlink and \link nostra::utils::thread::TaskQueue TaskQueueu \endlink, that provide functionality on a higher level).

Conceptually, the thread manager is internally little more than a priority queue for the Tasks and a pool that store the threads.

The maximum amount of threads that can be managed by the thread manager at the same time is (\link nostra::utils::thread::ThreadWrapper::maxThreads ThreadWrapper::maxThreads() \endlink - 1) (-1, because the main thread is not managed by the thread manager).

\subsection subsec_threadManager_Obtain Obtaining the Thread Manager
Nostra always provides an already constructed instance of the thread manager. It can be acquired using \link nostra::utils::thread::getThreadManager() getThreadManager() \endlink.

\attention
The first time that \link nostra::utils::thread::getThreadManager() getThreadManager() \endlink is getting called must be from the main thread. Otherwise the error handling will misbehave.

*/
